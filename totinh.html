<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
  <TITLE>Dành cho Min Min</TITLE>
  <style>
    html, body {
      height: 100%;
      padding: 0;
      margin: 0;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      font-family: 'Tahoma', sans-serif;
    }

    /* Lớp nền trái tim rơi */
    .heart-drop {
      position: fixed;
      top: -10%;
      color: #ff5ca4;
      font-size: 20px;
      z-index: 0;
      user-select: none;
      animation: fall linear infinite;
    }

    @keyframes fall {
      to { transform: translateY(110vh) rotate(360deg); }
    }

    .box {
      width: 100%;
      height: 100%;
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1;
    }

    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    /* ĐỊNH DẠNG HÌNH ẢNH Ở GIỮA */
    .heart-image-link {
        position: absolute;
        z-index: 10; 
        display: flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        /* Hiệu ứng đập cùng nhịp với trái tim (1.3s) */
        animation: animate 1.3s infinite;
    }

    .heart-avatar {
        width: 110px; /* Chỉnh cỡ ảnh tại đây */
        height: 110px;
        object-fit: cover;
        border-radius: 50%;
        border: 3px solid #FF5CA4;
        box-shadow: 0 0 15px rgba(255, 92, 164, 0.7);
    }

    #pinkboard {
      animation: animate 1.3s infinite;
    }

    @keyframes animate {
      0% { transform: scale(1); }
      30% { transform: scale(.8); }
      60% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .center-text {
      position: absolute;
      bottom: 10%;
      width: 100%;
      color: #FF5CA4;
      font-size: 35px;
      font-style: italic;
      text-align: center;
      z-index: 2;
      text-shadow: 0 0 10px #ff5ca4;
      transition: opacity 1s ease-in-out;
    }
  </style>
</HEAD>

<BODY>
  <div class="box">
    <canvas id="pinkboard"></canvas>
    
    <a href="anh.jpg" class="heart-image-link">
        <img src="anh.jpg" alt="Min Min" class="heart-avatar">
    </a>
  </div>

  <div id="text-effect" class="center-text">Anh yêu min min nhắm lun</div>

  <script>
    /* --- 1. Hiệu ứng Trái tim rơi --- */
    function createHeart() {
      const heart = document.createElement('div');
      heart.classList.add('heart-drop');
      heart.innerHTML = '❤️';
      heart.style.left = Math.random() * 100 + "vw";
      heart.style.animationDuration = Math.random() * 3 + 2 + "s";
      heart.style.opacity = Math.random();
      heart.style.fontSize = Math.random() * 20 + 10 + "px";
      document.body.appendChild(heart);
      setTimeout(() => { heart.remove(); }, 5000);
    }
    setInterval(createHeart, 200);

    /* --- 2. Hiệu ứng đổi chữ --- */
    const textElement = document.getElementById('text-effect');
    setTimeout(() => {
      textElement.style.opacity = 0;
      setTimeout(() => {
        textElement.innerHTML = "Anh yêu Min Min cụa a nhắmmm";
        textElement.style.opacity = 1;
      }, 1000);
    }, 4000); 

    /* --- 3. Phần Canvas (Giữ nguyên logic của bạn) --- */
    var settings = { particles: { length: 2000, duration: 2, velocity: 100, effect: -1.3, size: 13 } };
    (function(){var b=0;var c=["ms","moz","webkit","o"];for(var a=0;a<c.length&&!window.requestAnimationFrame;++a){window.requestAnimationFrame=window[c[a]+"RequestAnimationFrame"];window.cancelAnimationFrame=window[c[a]+"CancelAnimationFrame"]||window[c[a]+"CancelRequestAnimationFrame"]}if(!window.requestAnimationFrame){window.requestAnimationFrame=function(h,e){var d=new Date().getTime();var f=Math.max(0,16-(d-b));var g=window.setTimeout(function(){h(d+f)},f);b=d+f;return g}}if(!window.cancelAnimationFrame){window.cancelAnimationFrame=function(d){clearTimeout(d)}}}());
    var Point = (function() {
      function Point(x, y) { this.x = (typeof x !== 'undefined') ? x : 0; this.y = (typeof y !== 'undefined') ? y : 0; }
      Point.prototype.clone = function() { return new Point(this.x, this.y); };
      Point.prototype.length = function(length) { if (typeof length == 'undefined') return Math.sqrt(this.x * this.x + this.y * this.y); this.normalize(); this.x *= length; this.y *= length; return this; };
      Point.prototype.normalize = function() { var length = this.length(); this.x /= length; this.y /= length; return this; };
      return Point;
    })();
    var Particle = (function() {
      function Particle() { this.position = new Point(); this.velocity = new Point(); this.acceleration = new Point(); this.age = 0; }
      Particle.prototype.initialize = function(x, y, dx, dy) { this.position.x = x; this.position.y = y; this.velocity.x = dx; this.velocity.y = dy; this.acceleration.x = dx * settings.particles.effect; this.acceleration.y = dy * settings.particles.effect; this.age = 0; };
      Particle.prototype.update = function(deltaTime) { this.position.x += this.velocity.x * deltaTime; this.position.y += this.velocity.y * deltaTime; this.velocity.x += this.acceleration.x * deltaTime; this.velocity.y += this.acceleration.y * deltaTime; this.age += deltaTime; };
      Particle.prototype.draw = function(context, image) { function ease(t) { return (--t) * t * t + 1; } var size = image.width * ease(this.age / settings.particles.duration); context.globalAlpha = 1 - this.age / settings.particles.duration; context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size); };
      return Particle;
    })();
    var ParticlePool = (function() {
      var particles, firstActive = 0, firstFree = 0, duration = settings.particles.duration;
      function ParticlePool(length) { particles = new Array(length); for (var i = 0; i < particles.length; i++) particles[i] = new Particle(); }
      ParticlePool.prototype.add = function(x, y, dx, dy) { particles[firstFree].initialize(x, y, dx, dy); firstFree++; if (firstFree == particles.length) firstFree = 0; if (firstActive == firstFree) firstActive++; if (firstActive == particles.length) firstActive = 0; };
      ParticlePool.prototype.update = function(deltaTime) { var i; if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].update(deltaTime); } if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].update(deltaTime); for (i = 0; i < firstFree; i++) particles[i].update(deltaTime); } while (particles[firstActive].age >= duration && firstActive != firstFree) { firstActive++; if (firstActive == particles.length) firstActive = 0; } };
      ParticlePool.prototype.draw = function(context, image) { var i; if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].draw(context, image); } if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].draw(context, image); for (i = 0; i < firstFree; i++) particles[i].draw(context, image); } };
      return ParticlePool;
    })();
    (function(canvas) {
      var context = canvas.getContext('2d'), particles = new ParticlePool(settings.particles.length), particleRate = settings.particles.length / settings.particles.duration, time;
      function pointOnHeart(t) { return new Point(160 * Math.pow(Math.sin(t), 3), 130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25); }
      var image = (function() {
        var canvas = document.createElement('canvas'), context = canvas.getContext('2d');
        canvas.width = settings.particles.size; canvas.height = settings.particles.size;
        function to(t) { var point = pointOnHeart(t); point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350; point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350; return point; }
        context.beginPath(); var t = -Math.PI; var point = to(t); context.moveTo(point.x, point.y);
        while (t < Math.PI) { t += 0.01; point = to(t); context.lineTo(point.x, point.y); }
        context.closePath(); context.fillStyle = '#FF5CA4'; context.fill();
        var image = new Image(); image.src = canvas.toDataURL(); return image;
      })();
      function render() {
        requestAnimationFrame(render);
        var newTime = new Date().getTime() / 1000, deltaTime = newTime - (time || newTime); time = newTime;
        context.clearRect(0, 0, canvas.width, canvas.height);
        var amount = particleRate * deltaTime;
        for (var i = 0; i < amount; i++) {
          var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
          var dir = pos.clone().length(settings.particles.velocity);
          particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
        }
        particles.update(deltaTime); particles.draw(context, image);
      }
      function onResize() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
      window.onresize = onResize;
      setTimeout(function() { onResize(); render(); }, 10);
    })(document.getElementById('pinkboard'));
  </script>
</BODY>
</HTML>